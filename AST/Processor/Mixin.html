<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Module: AST::Processor::Mixin
  
    &mdash; Documentation by YARD 0.9.12
  
</title>

  <link rel="stylesheet" href="../../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "AST::Processor::Mixin";
  relpath = '../../';
</script>


  <script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../../_index.html">Index (M)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../../AST.html" title="AST (module)">AST</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Processor.html" title="AST::Processor (class)">Processor</a></span></span>
     &raquo; 
    <span class="title">Mixin</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Module: AST::Processor::Mixin
  
  
  
</h1>
<div class="box_info">
  

  
  
  
  
  

  
  <dl>
    <dt>Included in:</dt>
    <dd><span class='object_link'><a href="../Processor.html" title="AST::Processor (class)">AST::Processor</a></span></dd>
  </dl>
  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>lib/ast/processor/mixin.rb</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>The processor module is a module which helps transforming one
AST into another.  In a nutshell, the <span class='object_link'><a href="#process-instance_method" title="AST::Processor::Mixin#process (method)">#process</a></span> method accepts
a <span class='object_link'><a href="../Node.html" title="AST::Node (class)">Node</a></span> and dispatches it to a handler corresponding to its
type, and returns a (possibly) updated variant of the node.</p>

<p>The processor module has a set of associated design patterns.
They are best explained with a concrete example. Let’s define a
simple arithmetic language and an AST format for it:</p>

<p>Terminals (AST nodes which do not have other AST nodes inside):</p>

<ul>
  <li><code>(integer &lt;int-literal&gt;)</code>,</li>
</ul>

<p>Nonterminals (AST nodes with other nodes as children):</p>

<ul>
  <li><code>(add &lt;node&gt; &lt;node&gt;)</code>,</li>
  <li><code>(multiply &lt;node&gt; &lt;node&gt;)</code>,</li>
  <li><code>(divide &lt;node&gt; &lt;node&gt;)</code>,</li>
  <li><code>(negate &lt;node&gt;)</code>,</li>
  <li><code>(store &lt;node&gt; &lt;string-literal&gt;)</code>: stores value of <code>&lt;node&gt;</code>
into a variable named <code>&lt;string-literal&gt;</code>,</li>
  <li><code>(load &lt;string-literal&gt;)</code>: loads value of a variable named
<code>&lt;string-literal&gt;</code>,</li>
  <li><code>(each &lt;node&gt; ...)</code>: computes each of the <code>&lt;node&gt;</code>s and
prints the result.</li>
</ul>

<p>All AST nodes have the same Ruby class, and therefore they don’t
know how to traverse themselves. (A solution which dynamically
checks the type of children is possible, but is slow and
error-prone.) So, a class including the module which knows how
to traverse the entire tree should be defined.  Such classes
have a handler for each nonterminal node which recursively
processes children nodes:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_require'>require</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ast</span><span class='tstring_end'>&#39;</span></span>

<span class='kw'>class</span> <span class='const'>ArithmeticsProcessor</span>
  <span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../../AST.html" title="AST (module)">AST</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Processor.html" title="AST::Processor (class)">Processor</a></span></span><span class='op'>::</span><span class='const'>Mixin</span>
  <span class='comment'># This method traverses any binary operators such as (add)
</span>  <span class='comment'># or (multiply).
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_process_binary_op'>process_binary_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># Children aren&#39;t decomposed automatically; it is
</span>    <span class='comment'># suggested to use Ruby multiple assignment expansion,
</span>    <span class='comment'># as it is very convenient here.
</span>    <span class='id identifier rubyid_left_expr'>left_expr</span><span class='comma'>,</span> <span class='id identifier rubyid_right_expr'>right_expr</span> <span class='op'>=</span> <span class='op'>*</span><span class='id identifier rubyid_node'>node</span>

    <span class='comment'># AST::Node#updated won&#39;t change node type if nil is
</span>    <span class='comment'># passed as a first argument, which allows to reuse the
</span>    <span class='comment'># same handler for multiple node types using `alias&#39;
</span>    <span class='comment'># (below).
</span>    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='lbracket'>[</span>
      <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_left_expr'>left_expr</span><span class='rparen'>)</span><span class='comma'>,</span>
      <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_right_expr'>right_expr</span><span class='rparen'>)</span>
    <span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbol'>:on_add</span><span class='comma'>,</span>      <span class='symbol'>:process_binary_op</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbol'>:on_multiply</span><span class='comma'>,</span> <span class='symbol'>:process_binary_op</span>
  <span class='id identifier rubyid_alias_method'>alias_method</span> <span class='symbol'>:on_divide</span><span class='comma'>,</span>   <span class='symbol'>:process_binary_op</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_negate'>on_negate</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># It is also possible to use #process_all for more
</span>    <span class='comment'># compact code if every child is a Node.
</span>    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_store'>on_store</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_expr'>expr</span><span class='comma'>,</span> <span class='id identifier rubyid_variable_name'>variable_name</span> <span class='op'>=</span> <span class='op'>*</span><span class='id identifier rubyid_node'>node</span>

    <span class='comment'># Note that variable_name is not a Node and thus isn&#39;t
</span>    <span class='comment'># passed to #process.
</span>    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='lbracket'>[</span>
      <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='rparen'>)</span><span class='comma'>,</span>
      <span class='id identifier rubyid_variable_name'>variable_name</span>
    <span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='comment'># (load) is effectively a terminal node, and so it does
</span>  <span class='comment'># not need an explicit handler, as the following is the
</span>  <span class='comment'># default behavior.  Essentially, for any nodes that don&#39;t
</span>  <span class='comment'># have a defined handler, the node remains unchanged.
</span>  <span class='kw'>def</span> <span class='id identifier rubyid_on_load'>on_load</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='kw'>nil</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_each'>on_each</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span><span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Let’s test our ArithmeticsProcessor:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_include'>include</span> <span class='const'><span class='object_link'><a href="../../AST.html" title="AST (module)">AST</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Sexp.html" title="AST::Sexp (module)">Sexp</a></span></span>
<span class='id identifier rubyid_expr'>expr</span> <span class='op'>=</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>2</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>2</span><span class='rparen'>)</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>ArithmeticsProcessor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='rparen'>)</span> <span class='op'>==</span> <span class='id identifier rubyid_expr'>expr</span> <span class='comment'># =&gt; true
</span></code></pre>

<p>As expected, it does not change anything at all. This isn’t
actually very useful, so let’s now define a Calculator, which
will compute the expression values:</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># This Processor folds nonterminal nodes and returns an
</span><span class='comment'># (integer) terminal node.
</span><span class='kw'>class</span> <span class='const'>ArithmeticsCalculator</span> <span class='op'>&lt;</span> <span class='const'>ArithmeticsProcessor</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># First, node children are processed and then unpacked
</span>    <span class='comment'># to local variables.
</span>    <span class='id identifier rubyid_nodes'>nodes</span> <span class='op'>=</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_nodes'>nodes</span><span class='period'>.</span><span class='id identifier rubyid_all?'>all?</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span> <span class='op'>==</span> <span class='symbol'>:integer</span> <span class='rbrace'>}</span>
      <span class='comment'># If each of those nodes represents a literal, we can
</span>      <span class='comment'># fold this node!
</span>      <span class='id identifier rubyid_values'>values</span> <span class='op'>=</span> <span class='id identifier rubyid_nodes'>nodes</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_children'>children</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span> <span class='rbrace'>}</span>
      <span class='const'><span class='object_link'><a href="../../AST.html" title="AST (module)">AST</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="../Node.html" title="AST::Node (class)">Node</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="../Node.html#initialize-instance_method" title="AST::Node#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='lbracket'>[</span>
        <span class='kw'>yield</span><span class='lparen'>(</span><span class='id identifier rubyid_values'>values</span><span class='rparen'>)</span>
      <span class='rbracket'>]</span><span class='rparen'>)</span>
    <span class='kw'>else</span>
      <span class='comment'># Otherwise, we can just leave the current node in the
</span>      <span class='comment'># tree and only update it with processed children
</span>      <span class='comment'># nodes, which can be partially folded.
</span>      <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_updated'>updated</span><span class='lparen'>(</span><span class='kw'>nil</span><span class='comma'>,</span> <span class='id identifier rubyid_nodes'>nodes</span><span class='rparen'>)</span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_add'>on_add</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span><span class='op'>|</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>+</span> <span class='id identifier rubyid_right'>right</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_multiply'>on_multiply</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span><span class='op'>|</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>*</span> <span class='id identifier rubyid_right'>right</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Let’s check:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='const'>ArithmeticsCalculator</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr'>expr</span><span class='rparen'>)</span> <span class='comment'># =&gt; (integer 4)
</span></code></pre>

<p>Excellent, the calculator works! Now, a careful reader could
notice that the ArithmeticsCalculator does not know how to
divide numbers. What if we pass an expression with division to
it?</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_expr_with_division'>expr_with_division</span> <span class='op'>=</span> \
  <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>1</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:divide</span><span class='comma'>,</span>
      <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>8</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>4</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span>
      <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>3</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span> <span class='comment'># 1 + (8 + 4) / 3
</span>
<span class='id identifier rubyid_folded_expr_with_division'>folded_expr_with_division</span> <span class='op'>=</span> <span class='const'>ArithmeticsCalculator</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr_with_division'>expr_with_division</span><span class='rparen'>)</span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_folded_expr_with_division'>folded_expr_with_division</span>
<span class='comment'># =&gt; (add
</span><span class='comment'>#      (integer 1)
</span><span class='comment'>#      (divide
</span><span class='comment'>#        (integer 12)
</span><span class='comment'>#        (integer 3)))
</span></code></pre>

<p>As you can see, the expression was folded <em>partially</em>: the inner
<code>(add)</code> node which could be computed was folded to
<code>(integer 12)</code>, the <code>(divide)</code> node is left as-is because there
is no computing handler for it, and the root <code>(add)</code> node was
also left as it is because some of its children were not
literals.</p>

<p>Note that this partial folding is only possible because the
<em>data</em> format, i.e. the format in which the computed values of
the nodes are represented, is the same as the AST itself.</p>

<p>Let’s extend our ArithmeticsCalculator class further.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>ArithmeticsCalculator</span>
  <span class='kw'>def</span> <span class='id identifier rubyid_on_divide'>on_divide</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span><span class='op'>|</span> <span class='id identifier rubyid_left'>left</span> <span class='op'>/</span> <span class='id identifier rubyid_right'>right</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_negate'>on_negate</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># Note how #compute_op works regardless of the operator
</span>    <span class='comment'># arity.
</span>    <span class='id identifier rubyid_compute_op'>compute_op</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span> <span class='lbrace'>{</span> <span class='op'>|</span><span class='id identifier rubyid_value'>value</span><span class='op'>|</span> <span class='op'>-</span><span class='id identifier rubyid_value'>value</span> <span class='rbrace'>}</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<p>Now, let’s apply our renewed ArithmeticsCalculator to a partial
result of previous evaluation:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='const'>ArithmeticsCalculator</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_expr_with_division'>expr_with_division</span><span class='rparen'>)</span> <span class='comment'># =&gt; (integer 5)
</span></code></pre>

<p>Five! Excellent. This is also pretty much how CRuby 1.8 executed
its programs.</p>

<p>Now, let’s do some automated bug searching. Division by zero is
an error, right? So if we could detect that someone has divided
by zero before the program is even run, that could save some
debugging time.</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>class</span> <span class='const'>DivisionByZeroVerifier</span> <span class='op'>&lt;</span> <span class='const'>ArithmeticsProcessor</span>
  <span class='kw'>class</span> <span class='const'>VerificationFailure</span> <span class='op'>&lt;</span> <span class='const'>Exception</span><span class='semicolon'>;</span> <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_on_divide'>on_divide</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
    <span class='comment'># You need to process the children to handle nested divisions
</span>    <span class='comment'># such as:
</span>    <span class='comment'># (divide
</span>    <span class='comment'>#   (integer 1)
</span>    <span class='comment'>#   (divide (integer 1) (integer 0))
</span>    <span class='id identifier rubyid_left'>left</span><span class='comma'>,</span> <span class='id identifier rubyid_right'>right</span> <span class='op'>=</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>

    <span class='kw'>if</span> <span class='id identifier rubyid_right'>right</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span> <span class='op'>==</span> <span class='symbol'>:integer</span> <span class='op'>&amp;&amp;</span>
       <span class='id identifier rubyid_right'>right</span><span class='period'>.</span><span class='id identifier rubyid_children'>children</span><span class='period'>.</span><span class='id identifier rubyid_first'>first</span> <span class='op'>==</span> <span class='int'>0</span>
      <span class='id identifier rubyid_raise'>raise</span> <span class='const'>VerificationFailure</span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ouch! This code divides by zero.</span><span class='tstring_end'>&quot;</span></span>
    <span class='kw'>end</span>
  <span class='kw'>end</span>

  <span class='kw'>def</span> <span class='id identifier rubyid_divides_by_zero?'>divides_by_zero?</span><span class='lparen'>(</span><span class='id identifier rubyid_ast'>ast</span><span class='rparen'>)</span>
    <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_ast'>ast</span><span class='rparen'>)</span>
    <span class='kw'>false</span>
  <span class='kw'>rescue</span> <span class='const'>VerificationFailure</span>
    <span class='kw'>true</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>

<span class='id identifier rubyid_nice_expr'>nice_expr</span> <span class='op'>=</span> \
  <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:divide</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>10</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>2</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>4</span><span class='rparen'>)</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>DivisionByZeroVerifier</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_divides_by_zero?'>divides_by_zero?</span><span class='lparen'>(</span><span class='id identifier rubyid_nice_expr'>nice_expr</span><span class='rparen'>)</span>
<span class='comment'># =&gt; false. Good.
</span>
<span class='id identifier rubyid_bad_expr'>bad_expr</span> <span class='op'>=</span> \
  <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:add</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>10</span><span class='rparen'>)</span><span class='comma'>,</span>
    <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:divide</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>1</span><span class='rparen'>)</span><span class='comma'>,</span> <span class='id identifier rubyid_s'>s</span><span class='lparen'>(</span><span class='symbol'>:integer</span><span class='comma'>,</span> <span class='int'>0</span><span class='rparen'>)</span><span class='rparen'>)</span><span class='rparen'>)</span>

<span class='id identifier rubyid_p'>p</span> <span class='const'>DivisionByZeroVerifier</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='period'>.</span><span class='id identifier rubyid_divides_by_zero?'>divides_by_zero?</span><span class='lparen'>(</span><span class='id identifier rubyid_bad_expr'>bad_expr</span><span class='rparen'>)</span>
<span class='comment'># =&gt; true. WHOOPS. DO NOT RUN THIS.
</span></code></pre>

<p>Of course, this won’t detect more complex cases… unless you
use some partial evaluation before! The possibilites are
endless. Have fun.</p>


  </div>
</div>
<div class="tags">
  

</div>






  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#handler_missing-instance_method" title="#handler_missing (instance method)">#<strong>handler_missing</strong>(node)  &#x21d2; AST::Node<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Default handler.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#process-instance_method" title="#process (instance method)">#<strong>process</strong>(node)  &#x21d2; AST::Node<sup>?</sup> </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Dispatches <code>node</code>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#process_all-instance_method" title="#process_all (instance method)">#<strong>process_all</strong>(nodes)  &#x21d2; Array&lt;AST::Node&gt; </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p><span class='object_link'><a href="#process-instance_method" title="AST::Processor::Mixin#process (method)">#process</a></span>es each node from <code>nodes</code> and returns an array of results.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="handler_missing-instance_method">
  
    #<strong>handler_missing</strong>(node)  &#x21d2; <tt><span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span></tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Default handler. Does nothing.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>node</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


284
285</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ast/processor/mixin.rb', line 284</span>

<span class='kw'>def</span> <span class='id identifier rubyid_handler_missing'>handler_missing</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="process-instance_method">
  
    #<strong>process</strong>(node)  &#x21d2; <tt><span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span></tt><sup>?</sup> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Dispatches <code>node</code>. If a node has type <code>:foo</code>, then a handler
named <code>on_foo</code> is invoked with one argument, the <code>node</code>; if
there isn’t such a handler, <span class='object_link'><a href="#handler_missing-instance_method" title="AST::Processor::Mixin#handler_missing (method)">#handler_missing</a></span> is invoked
with the same argument.</p>

<p>If the handler returns <code>nil</code>, <code>node</code> is returned; otherwise,
the return value of the handler is passed along.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>node</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ast/processor/mixin.rb', line 251</span>

<span class='kw'>def</span> <span class='id identifier rubyid_process'>process</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
  <span class='kw'>return</span> <span class='kw'>if</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_nil?'>nil?</span>

  <span class='id identifier rubyid_node'>node</span> <span class='op'>=</span> <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_to_ast'>to_ast</span>

  <span class='comment'># Invoke a specific handler
</span>  <span class='id identifier rubyid_on_handler'>on_handler</span> <span class='op'>=</span> <span class='symbol'>:on_</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_type'>type</span><span class='embexpr_end'>}</span><span class='tstring_end'>&quot;</span></span>
  <span class='kw'>if</span> <span class='id identifier rubyid_respond_to?'>respond_to?</span> <span class='id identifier rubyid_on_handler'>on_handler</span>
    <span class='id identifier rubyid_new_node'>new_node</span> <span class='op'>=</span> <span class='id identifier rubyid_send'>send</span> <span class='id identifier rubyid_on_handler'>on_handler</span><span class='comma'>,</span> <span class='id identifier rubyid_node'>node</span>
  <span class='kw'>else</span>
    <span class='id identifier rubyid_new_node'>new_node</span> <span class='op'>=</span> <span class='id identifier rubyid_handler_missing'>handler_missing</span><span class='lparen'>(</span><span class='id identifier rubyid_node'>node</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_node'>node</span> <span class='op'>=</span> <span class='id identifier rubyid_new_node'>new_node</span> <span class='kw'>if</span> <span class='id identifier rubyid_new_node'>new_node</span>

  <span class='id identifier rubyid_node'>node</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="process_all-instance_method">
  
    #<strong>process_all</strong>(nodes)  &#x21d2; <tt>Array&lt;<span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span>&gt;</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p><span class='object_link'><a href="#process-instance_method" title="AST::Processor::Mixin#process (method)">#process</a></span>es each node from <code>nodes</code> and returns an array of
results.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>nodes</span>
      
      
        <span class='type'>(<tt>Array&lt;<span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Array&lt;<span class='object_link'><a href="../Node.html" title="AST::Node (class)">AST::Node</a></span>&gt;</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


274
275
276
277
278</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/ast/processor/mixin.rb', line 274</span>

<span class='kw'>def</span> <span class='id identifier rubyid_process_all'>process_all</span><span class='lparen'>(</span><span class='id identifier rubyid_nodes'>nodes</span><span class='rparen'>)</span>
  <span class='id identifier rubyid_nodes'>nodes</span><span class='period'>.</span><span class='id identifier rubyid_to_a'>to_a</span><span class='period'>.</span><span class='id identifier rubyid_map'>map</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_node'>node</span><span class='op'>|</span>
    <span class='id identifier rubyid_process'>process</span> <span class='id identifier rubyid_node'>node</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Thu Nov  8 04:08:02 2018 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.12 (ruby-2.5.1).
</div>

    </div>
  </body>
</html>